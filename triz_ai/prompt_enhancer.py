"""
LLM Prompt Enhancer
===================

This module defines a helper function ``enhance_formula`` that takes a patent
claim (formula) generated by ``generate_formula.generate_formula`` and
produces suggestions to improve the title, identify non‑obvious features
and provide a patentability justification.  The primary goal is to
demonstrate how a Large Language Model (LLM) such as OpenAI's GPT series
could be integrated into the workflow to provide richer feedback beyond
simple heuristic analysis.

If an OpenAI API key is available and the ``openai`` package is installed,
the function will call the model to generate suggestions.  Otherwise, it
falls back to a heuristic implementation that parses the formula using
``extract_features`` from ``generate_formula.py`` and generates simple
recommendations.

Example usage::

    from prompt_enhancer import enhance_formula
    formula = generate_formula(idea_text)
    enhancements = enhance_formula(formula)
    print(enhancements['title'])
    print(enhancements['non_obvious_suggestions'])
    print(enhancements['justification'])

This file does not store any API keys; to use the OpenAI integration you
must set the environment variable ``OPENAI_API_KEY``.
"""

from __future__ import annotations

import os
import json
from typing import Dict, Optional

from .generate_formula import extract_features 
import re


def enhance_formula(
    formula: str,
    openai_api_key: Optional[str] = None,
    model: str = "gpt-3.5-turbo",
    provider: str = "openai",
    **provider_kwargs: object,
) -> Dict[str, str]:
    """Generates enhancements for a patent claim using various LLM providers or heuristics.

    Parameters
    ----------
    formula : str
        The patent claim (first claim) generated by ``generate_formula``.
    openai_api_key : str, optional
        An OpenAI API key.  If provided and the ``openai`` package is
        available, the function will query the model specified by
        ``model``.  If not provided or if the call fails, a heuristic
        fallback is used.
    model : str, optional
        The OpenAI model to use when calling the API, by default
        ``gpt-3.5-turbo``.

    Returns
    -------
    Dict[str, str]
        A dictionary with keys ``title``, ``non_obvious_suggestions`` and
        ``justification`` containing textual recommendations.
    """
    # Use API key from argument or environment
    # Determine API key from argument or environment
    api_key = openai_api_key or os.getenv("OPENAI_API_KEY")

    # Provider dispatch: openai (default), azure, anthropic, mistral
    provider_name = provider.lower() if provider else "openai"
    if api_key:
        if provider_name == "openai":
            try:
                import openai  # type: ignore
                openai.api_key = api_key
                # Compose system prompt
                system_prompt = (
                    "You are a patent attorney's assistant. Given a patent claim, you "
                    "should propose: (1) a more descriptive title that conveys the "
                    "essence of the invention and its technical effect; (2) identify "
                    "which distinctive features appear non‑obvious when compared to "
                    "known solutions and why; (3) provide a justification of "
                    "patentability referencing novelty and inventive step. Respond "
                    "in JSON with keys 'title', 'non_obvious_suggestions' and "
                    "'justification'."
                )
                user_prompt = f"Patent claim: {formula}\nPlease provide the analysis."
                response = openai.ChatCompletion.create(
                    model=model,
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": user_prompt},
                    ],
                    temperature=0.7,
                    max_tokens=400,
                )
                content = response["choices"][0]["message"]["content"]
                # Try to parse JSON from the response
                try:
                    result = json.loads(content)
                    return {
                        "title": result.get("title", ""),
                        "non_obvious_suggestions": result.get("non_obvious_suggestions", ""),
                        "justification": result.get("justification", ""),
                    }
                except Exception:
                    return {
                        "title": "",
                        "non_obvious_suggestions": "",
                        "justification": content.strip(),
                    }
            except Exception:
                pass
        elif provider_name == "azure":
            # Azure OpenAI uses same openai library with additional parameters
            try:
                import openai  # type: ignore
                openai.api_type = "azure"
                openai.api_key = api_key
                # Provider kwargs must include api_base and api_version
                openai.api_base = provider_kwargs.get("api_base", os.getenv("AZURE_OPENAI_API_BASE", ""))
                openai.api_version = provider_kwargs.get("api_version", os.getenv("AZURE_OPENAI_API_VERSION", "2023-03-15-preview"))
                deployment_name = provider_kwargs.get("deployment_name", os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME", ""))
                if not openai.api_base or not deployment_name:
                    raise ValueError("Azure OpenAI requires api_base and deployment_name")
                system_prompt = (
                    "You are a patent attorney's assistant. Given a patent claim, you "
                    "should propose: (1) a more descriptive title that conveys the "
                    "essence of the invention and its technical effect; (2) identify "
                    "which distinctive features appear non‑obvious when compared to "
                    "known solutions and why; (3) provide a justification of "
                    "patentability referencing novelty and inventive step. Respond "
                    "in JSON with keys 'title', 'non_obvious_suggestions' and "
                    "'justification'."
                )
                user_prompt = f"Patent claim: {formula}\nPlease provide the analysis."
                response = openai.ChatCompletion.create(
                    engine=deployment_name,
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": user_prompt},
                    ],
                    temperature=0.7,
                    max_tokens=400,
                )
                content = response["choices"][0]["message"]["content"]
                try:
                    result = json.loads(content)
                    return {
                        "title": result.get("title", ""),
                        "non_obvious_suggestions": result.get("non_obvious_suggestions", ""),
                        "justification": result.get("justification", ""),
                    }
                except Exception:
                    return {
                        "title": "",
                        "non_obvious_suggestions": "",
                        "justification": content.strip(),
                    }
            except Exception:
                pass
        elif provider_name == "anthropic":
            try:
                import anthropic  # type: ignore
                client = anthropic.Client(api_key=api_key)
                system_prompt = (
                    "You are a patent attorney's assistant. Given a patent claim, you "
                    "should propose: (1) a more descriptive title that conveys the "
                    "essence of the invention and its technical effect; (2) identify "
                    "which distinctive features appear non‑obvious when compared to "
                    "known solutions and why; (3) provide a justification of "
                    "patentability referencing novelty and inventive step. Respond "
                    "in JSON with keys 'title', 'non_obvious_suggestions' and "
                    "'justification'."
                )
                user_prompt = f"Patent claim: {formula}\nPlease provide the analysis."
                message = client.chat(
                    model=provider_kwargs.get("anthropic_model", "claude-2"),
                    messages=[{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}],
                    temperature=0.7,
                    max_tokens=400,
                )
                content = message["content"] if isinstance(message, dict) else ""
                try:
                    result = json.loads(content)
                    return {
                        "title": result.get("title", ""),
                        "non_obvious_suggestions": result.get("non_obvious_suggestions", ""),
                        "justification": result.get("justification", ""),
                    }
                except Exception:
                    return {
                        "title": "",
                        "non_obvious_suggestions": "",
                        "justification": content.strip(),
                    }
            except Exception:
                pass
        elif provider_name == "mistral":
            # Placeholder for local or other open-source model integration
            # Expect a callable in provider_kwargs named mistral_fn that takes formula and returns dict
            mistral_fn = provider_kwargs.get("mistral_fn")
            if callable(mistral_fn):
                try:
                    result = mistral_fn(formula)
                    if isinstance(result, dict):
                        return {
                            "title": result.get("title", ""),
                            "non_obvious_suggestions": result.get("non_obvious_suggestions", ""),
                            "justification": result.get("justification", ""),
                        }
                except Exception:
                    pass


    # Heuristic fallback: use extract_features to parse formula
    features = extract_features(formula)
    name = features.get("name", "")
    distinctive = features.get("distinctive", "")
    effect = features.get("effect", "")

    # Improved title: emphasise effect if present
    if effect:
        title = f"Устройство для {effect}"
    elif name:
        # Remove generic words like "устройство" or "способ" from the name
        title_tokens = [t for t in name.split() if t.lower() not in {"устройство", "способ", "система"}]
        title = "Усовершенствованное " + " ".join(title_tokens)
    else:
        title = "Усовершенствованное техническое решение"

    # Non‑obvious suggestions: look at distinctive features and highlight combinations
    non_obv = []
    if distinctive:
        # Split by comma or conjunctions
        items = re.split(r"[,;]", distinctive)
        items = [i.strip() for i in items if i.strip()]
        # Suggest synergy between features
        if len(items) > 1:
            non_obv.append(
                "Комбинация признаков " + " + ".join(items[:2]) + " дает неожиданный эффект, который не предсказывался из известного уровня техники."
            )
        for item in items:
            non_obv.append(
                f"Признак '{item}' может быть признан неочевидным, если в известных решениях отсутствует его сочетание с другими элементами конструкции."
            )
    else:
        non_obv.append(
            "Нет явно выделенных отличительных признаков, поэтому оценка неочевидности затруднительна."
        )

    # Justification: emphasise novelty and inventive step
    justification_parts = []
    if distinctive:
        justification_parts.append(
            "Совокупность отличительных признаков обеспечивает технический эффект, который не достигается прототипом."
        )
    if effect:
        justification_parts.append(
            f"Заявленный эффект ('{effect}') подтверждает наличие изобретательского уровня, так как известно, что подобный результат не был предсказуем."
        )
    if not justification_parts:
        justification_parts.append(
            "Формула не содержит достаточных данных для обоснования патентоспособности."
        )

    return {
        "title": title,
        "non_obvious_suggestions": "\n".join(non_obv),
        "justification": "\n".join(justification_parts),
    }


def export_enhancement_report(enhancements: Dict[str, str], filename: str) -> None:
    """Exports the results of `enhance_formula` to a .docx file.

    The report contains sections for the improved title, non‑obviousness
    suggestions and patent justification.  It uses a minimal Office XML
    structure similar to ``export_report`` in ``triz_system.py``.  The
    function accepts either a file path or a binary file‑like object.

    Parameters
    ----------
    enhancements : Dict[str, str]
        Dictionary returned by ``enhance_formula`` containing keys
        ``title``, ``non_obvious_suggestions`` and ``justification``.
    filename : str or file-like object
        Path to the output .docx file or a file‑like object (e.g. ``BytesIO``).
    """
    from zipfile import ZipFile, ZIP_DEFLATED
    # Escape XML special characters
    def escape(text: str) -> str:
        return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

    title = escape(enhancements.get("title", ""))
    suggestions = escape(enhancements.get("non_obvious_suggestions", ""))
    justification = escape(enhancements.get("justification", ""))
    # Build document XML
    doc = []
    doc.append('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
    doc.append('<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">')
    doc.append('  <w:body>')
    # Title paragraph
    doc.append('    <w:p><w:r><w:t>Улучшенное название:</w:t></w:r></w:p>')
    doc.append(f'    <w:p><w:r><w:t>{title}</w:t></w:r></w:p>')
    # Suggestions paragraph
    doc.append('    <w:p><w:r><w:t>Подсказки по неочевидности:</w:t></w:r></w:p>')
    for line in suggestions.split('\n'):
        doc.append(f'    <w:p><w:r><w:t>{line}</w:t></w:r></w:p>')
    # Justification paragraph
    doc.append('    <w:p><w:r><w:t>Обоснование патентоспособности:</w:t></w:r></w:p>')
    for line in justification.split('\n'):
        doc.append(f'    <w:p><w:r><w:t>{line}</w:t></w:r></w:p>')
    # Close body and document
    doc.append('    <w:sectPr/>')
    doc.append('  </w:body>')
    doc.append('</w:document>')
    document_xml = "\n".join(doc)
    # [Content_Types].xml and rels
    ct_xml = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>'''
    rels_xml = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="R1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>'''
    # Write to zip
    if hasattr(filename, 'write'):
        zf = ZipFile(filename, 'w', ZIP_DEFLATED)
        zf.writestr('[Content_Types].xml', ct_xml)
        zf.writestr('_rels/.rels', rels_xml)
        zf.writestr('word/document.xml', document_xml)
        zf.close()
    else:
        with ZipFile(filename, 'w', ZIP_DEFLATED) as zf:
            zf.writestr('[Content_Types].xml', ct_xml)
            zf.writestr('_rels/.rels', rels_xml)
            zf.writestr('word/document.xml', document_xml)
